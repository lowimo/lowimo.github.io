<!DOCTYPE html>
<html>

<head>
    <title>Ramblings on Software</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto">

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
        }

        :root {
            /* font-family: Roboto, Tahoma, sans-serif; */
            font-family: system-ui;
            line-height: 1.5;
        }

        html {
            color-scheme: light dark;
        }

        body {
            max-width: min(90ch, 100% - 4rem);
            margin: 1em auto 5em auto;
            background-color: white;
            color: #222;
        }

        article {
            margin-bottom: 1.5em;
            display: flex;
            flex-direction: column;
            gap: 0.7em;
            border-top: 1px solid #ddd;
            padding-top: 1em;
        }

        aside {
            color: #555;
            margin-top: 0.1em;
        }

        h1 {
            font-size: 2em;
        }

        h2 {
            font-size: 1.7em;
        }

        h3 {
            font-size: 1.3em;
            font-weight: 500;
        }

        p {
            margin-bottom: 0.7em;
        }

        ul {
            /* list-style: none; */
            padding: 0;
            margin-left: 1.5em;
            display: flex;
            flex-direction: column;
            gap: 0.5em;
        }

        a {
            font-weight: 600;
        }

        #vid-art a::before {
            content: '»';
        }

        li>ul {
            margin-top: 0.5em;
        }

        header {
            display: flex;
            align-items: center;
            gap: 1em;
            margin-bottom: 1.5em;
        }

        a,
        a:active a:visited {
            color: #2323a1;
            text-decoration: none;
        }

        a:hover {
            color: #4d4da1;
        }

        .warning {
            display: flex;
            flex-direction: row;
            gap: 1em;
            font-weight: 600;
        }
    </style>
</head>

<body>

    <header>
        <div>
            <h1>Ramblings on Software</h1>
            <aside>A collection of opinions on software engineering and architecture</aside>
            <aside>by CR</aside>
        </div>
    </header>

    <article id="vid-art">
        <h2>Links</h2>
        <div>
            An incredibly outdated collection of links to stuff that I found interesting:
        </div>
        <div>
            <a href="https://www.youtube.com/watch?v=88_LUw1Wwe4" target="_blank">
                Top 5 techniques for building the worst microservice system ever - William Brander - NDC London 2023
            </a>
            <aside>Fun and easy to understand overview of common pitfalls with microservices.</aside>
        </div>
        <div>
            <a href="https://daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/" target="_blank">
                How Developers Stop Learning: Rise of the Expert Beginner
            </a>
            <aside>An observation on engineers, who think that they have found the "best" way to do things.</aside>
        </div>
        <div>
            <a href="https://www.youtube.com/watch?v=099cHWSbAL8" target="_blank">
                How to crash an airplane – Nickolas Means | The Lead Developer UK 2016
            </a>
            <aside>A nice story about how teams should work together.</aside>
        </div>
        <div>
            <a href="https://www.youtube.com/watch?v=QVBlnCTu9Ms" target="_blank">
                #NoEstimates (Allen Holub)
            </a>
            <aside>Why estimation is hard and the consequences for management.</aside>
        </div>
    </article>

    <article>
        <h2>Guidelines</h2>
        <div>Many of the following guidelines are specific to .NET,
            simply because that is the ecosystem I have the most experience with.</div>
        <div class="warning">
            <img src="icons/triangle-alert.svg" width="30px">
            <div>
                <div>These are guidelines, not rules.</div>
                <div>Use them as a reasonable default option.</div>
                <div>Break them when oppropriate, but understand the risks and implications.</div>
            </div>
        </div>

        <h3>Databases</h3>
        <ul>
            <li>Avoid Guids as keys or index columns for tables that will have more than 100 rows. If you have to, use Guids created in the v7 format to avoid unnecessary index fragmentation and latency spikes when the DB has to organize pages.</li>
            <li>Avoid Guids (uniqueidentifier) even more when you are using MS SQL Server, because SQL Server does NOT order Guids the way any reasonably sane person would think they should be ordered.</li>
            <li>Design your schemas so that inserts and deletes happen mostly at the very start or end of the clustered index - like a queue.</li>
        </ul>

        <h3>EF Core</h3>
        <ul>
            <li>Think about your database schema and the most common access patterns first before writing your EF entities in code.
                When in doubt, prefer a nice and fast DB schema over nice code!</li>
            <li>Always think about concurrency and data integrity
                <ul>
                    <li>Use atomic methods like ExecuteUpdate or ExecuteDelete if possible</li>
                    <li>Handle concurrency conflicts -> <a href="https://learn.microsoft.com/en-us/ef/core/saving/concurrency">https://learn.microsoft.com/en-us/ef/core/saving/concurrency</a></li>
                    <li>Design your schema to reduce the need to even think about concurrency!</li>
                </ul>
            </li>
            <li>Always know and understand the generated SQL.</li>
            <li>Do not try to solve concurrency problems in code when battle-hardened atomic primitives exist in SQL.</li>
            <li>Consider using Dapper instead, especially for use-cases with high load, concurrency, or other performance requirements.</li>
            <li>Set AsNoTracking as default.</li>
            <li>Use a separate DB context per feature.</li>
            <li>Use a DB context factory instead of directly injected DB context.</li>
            <li>Keep the lifetime of a DB context as short as possible (but as long as necessary) and handle its lifetime explicitly instead of through DI lifetimes.</li>

        </ul>

        <h3>API Design</h3>
        <ul>
            <li>Give every feature a well-designed API</li>
            <li>Do NOT assume the lifecycle of the caller (they might be a short-lived API controller instance or a long-lived background service, both has to work)</li>
            <li>Do NOT leak implementation details (e.g. internal DTOs or DB entities)</li>
            <li>Do NOT allow the representation of states that are invalid for the domain (e.g. if you have two properties but the allowed values in one depends on the value in the other, choose a different design)</li>
            <li>DO use types that clearly show what promises your API makes</li>
            <li>Do NOT use types that give away the APIs ability to change implementation details</li>
            <li>Use OneOf (or similar) to represent all states that are important for the domain or that you want the caller to handle. But: What is important for the domain is different for each layer of abstraction, because the domain is different!
            </li>
            <li>Use Exceptions for cases that the caller cannot reasonably handle (e.g. DB not available, internal invariants violated)</li>
            <li>All public methods should be thread-safe. This sounds restrictive but is usually no significant overhead at all, and it makes writing concurrent processes much easier.</li>
            <li>Prefer singleton DI lifetimes over transient or context lifetimes. Short lifetimes have several downsides:
                <ul>
                    <li>They suggest that the implementation does not need to care about thread-safety (e.g. when handling a DB context) but as soon as you want to introduce concurrency (e.g. because you want to call multiple async methods but await
                        them later) this illusion quickly leads to errors.</li>
                    <li>They produce garbage.</li>
                </ul>
            </li>
        </ul>

        <h3>Error Handling</h3>
        <ul>
            <li>When switching on an enum value and the default case is unexpected (aka a bug), include the offending value in the exception message.</li>
        </ul>

        <h3>Dates and Times</h3>
        <ul>
            <li>Consider using NodaTime instead and use more explicit types.</li>
            <li>Use DateTime when you want to specify a point in time.</li>
            <li>DateTime fields should be either UTC or local, not mixed.</li>
            <li>DateTime fields should specify in their name if they are UTC or local.</li>
            <li>Do NOT use DateTime to refer to days or times (use DateOnly and TimeOnly instead).</li>
        </ul>

        <h3>Logging</h3>
        <ul>
            <li>Log information that is actually interesting and valuable for debugging.</li>
            <li>Write logs in complete English sentences.</li>
        </ul>

        <h3>Naming</h3>
        <ul>
            <li>The term "ViewModel" should be used for mutable types used for data-binding.</li>
            <li>The term "DTO" should be used for types that represent a data contract and are used for serialization.</li>
            <li>The term "Model" by itself is too generic and should be avoided.</li>
            <li>Types that represent domain objects should use the name established in the domain without further suffix.</li>
        </ul>

        <h3>Process Startup</h3>
        <ul>
            <li>Always set current culture to invariant.</li>
        </ul>

        <h3>Libraries</h3>
        <ul>
            <li>Every imported nuget package is both a chance to save time and an additional risk:
                <ul>
                    <li>Unnecessary complexity increases cognitive load.</li>
                    <li>Licensing may change.</li>
                    <li>Bugs and technical debt in libraries lead to workarounds, which further increase cognitive load.</li>
                    <li>Types from a library that are used in many places should be conceptually simple enough that you are able to replace them with your own implementation, if it ever becomes necessary.</li>
                </ul>
            </li>
            <li>Don't reinvent the wheel. But also don't use a complicated wheel when a simple wheel that you have full control over will suffice.</li>
            <li>Prefer the OneOf package over LanguageExt (LanguageExt feels overblown).</li>
            <li>Avoid AutoMapper (and similar) and Mediator.</li>
        </ul>

        <h3>Build & Environment</h3>
        <ul>
            <li>Enable TreatWarningsAsErrors - Without it, important (breaking or non-breaking) changes in libraries or new .NET version can easily get drowned in unimportant warnings.</li>
            <li>Use the new SLNX solution format by default.</li>
        </ul>

    </article>

</body>

</html>